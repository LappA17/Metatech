'use strict';

//EventEmitter - это такой паттерн, который позволяет нам создавать объект, обвешивать его несколькими обработчиками событий(каждое событие имеет имя) и массив обработчиком. Потом EventEmitter может быть доступен из разных частей программы, одни части программы могут навешиваться на события, а другие могут Эмитить эти события(присылать) и когда они присылают эти события, то все кто на них подписался - получают вызов функции и получают данные. Каждый коллбек навешанный на EventEmitter может вызываться от 0 до много кства раз. В Ноде он есть, в браузере нет, но можно спокойно его написать руками. Фактически EventEmitter - это такая абстракция, как шина событий через которую разные части програмы могут взаимодействовать !
//EventEmitter делается в основном для слабо связыванного кода. То-есть когда мы не можем передать ссылку на фцию(или на какое-то АПИ, интерфейс) из одного места программы в другую - мы заранее не знаем будет ли кто-то в этой программе слушать эти вызовы и в результате мы не можем вызвать фцию, а может там и никто не хочет что бы его вызывали, но событие мы можем послать и если на него никто не подписался то мы просто его проглотим

//здесь мы создаем constructor прототипа и в нём заготавливаем специальный коллекшен событий
const EventEmitter = function () {
  this.events = {}; // hash of array of function
  //Это будет выглядить след образом: this.events = { name1: [fn1, fn2 и тд]} те много фций на одном именни ы
};

//на прототип вешаем две метода on и ниже emit. Метод on - для того что бы навешивать какие-то события, а метод emit - что бы их отправлять
EventEmitter.prototype.on = function (name, fn) {
  //дальше мы проверяем есть ли у нашего event emitter уже в коллекции событий такое событие
  const event = this.events[name];
  //если не пустой то мы понимаем что там массив, и мы пушем эту фцию
  if (event) event.push(fn);
  //если никакого array в этом коллекшене мы не нашли то создаем первый элемент массива и помещаем по имени
  else this.events[name] = [fn]; // будет так this.events = { name1: [fn] }
};

//мы берём name и остальные аргументы помещаем в data массив
EventEmitter.prototype.emit = function (name, ...data) {
  const event = this.events[name];
  if (!event) return;
  //если event есть то мы проходися по всем элементам массива, берём фции и на каждой иттерации выполняем эту фцию разворачивая все прикрепленные аргументы в массиве data
  for (const listener of event) listener(...data);
};

module.exports = EventEmitter;

//Здесь в примере только два метода у ЕвенЕмиттера но вообще может быть много методов
