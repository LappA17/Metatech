'use strict';

//здесь мы посмотрим какие ещё фции могут быть в EventEmitter
//здесь точно так же реализация на замыканиях

const emitter = () => {
  let events = {};
  const ee = {
    //on - навешивает события
    on: (name, f, timeout = 0) => {
      const event = events[name] || [];
      events[name] = event;
      event.push(f);
      if (timeout)
        setTimeout(() => {
          ee.remove(name, f);
        }, timeout);
    },
    //emit присылает события и прикрепляет к ним данные
    emit: (name, ...data) => {
      const event = events[name];
      if (event) event.forEach(f => f(...data));
    },
    //once навешивает коллбек таким образом что только первый эмит случится, то-есть фция f вызовится только после того как первый раз кто-то сделает emit вот этого name, а при втором эмитте этот f не сработает. Потому что внутри есть обёртка навешивает на событие не фцию f которая приходит, а фцию g которая лежит внутри обёртки, фция f попадает в фцию g из замыкания. И как только кто-то вызывает фцию g - мы саму фцию g вынимаем(убераем) из EventEmitter, то-есть при пермов вызове эмитта по этому name фция g просто удалит сама себя и потом вызовет фцию f
    once: (name, f) => {
      const g = (...a) => {
        ee.remove(name, g);
        f(...a);
      };
      ee.on(name, g);
    },
    //Здесь мы точно так же ищем в коллекшене массив по имени(нужно нам событие) -> если не нашли то выходим -> у нас есть фция f и нам нужно её снять с события и теперь у нас есть array фций и фция f и нужно найти эту фцию в array и это нам позволяет сделать мтеод indexOf и в переменную i поместится в какой позиции находится эта фция в массиве -> если эта фция в массиве не нашлась - значит кто-то хочет нас обмануть и передаёт какуе-то фция для удаления которая на самом деле на событие не весела -> а если все норм то делаем event.splice(i, 1);
    remove: (name, f) => {
      const event = events[name];
      if (!event) return;
      const i = event.indexOf(f);
      if (i !== -1) event.splice(i, 1);
    },
    //clear - удаляет все обработчики событий, если мы в этот clear передаём какое-то конкретное имя события то тогда мы находим этот массив в коллекшене событий и удаляем, а если имени не передавали то просто чистим всю коллекцию
    clear: name => {
      if (name) delete events[name];
      else events = {};
    },
    //count - посчитает сколько обработчиком на каждом событие у нас в данный момент весит. Мы точно так же ищем это событие в коллекшене
    count: name => {
      const event = events[name];
      return event ? event.length : 0;
    },
    //listeners - должен вернуть нам массив обработчиком какого-то конкретного события, если из 10 мест программы кто-то навесил 10 обработчиков то мы хотим получить массив этих обработчиков. Сначала мы находим этот массив в нашем коллекшене -> вызываем event.slice() слайс без аргументов просто даст нам копию этого массива. И тут вопрос почему мы не можем сразу отдать массив обработчиков через events[name]; - дело в том что если мы так сделаем то мы ссылку на этот массив отдадим пользователю EventEmitter и он там что-то может пропатчить, изменить и мы потеряем контроль над коллекцией событий, а так мы ему отдаем только копию
    listeners: name => {
      const event = events[name];
      return event.slice();
    },
    //получаем именна всех существующих событий, просто в Объекте забираем все ключи
    names: () => Object.keys(events),
  };
  return ee; //возвращается из всей нашей фции объект напичканный методами
};

// Usage

const ee = emitter();

// on and emit

ee.on('e1', data => {
  console.dir(data);
});

ee.emit('e1', { msg: 'e1 ok' });

// once

//тестируем как работает once
ee.once('e2', data => {
  console.dir(data);
});

//наш once расспечатает только первый объект, а второй уже нет
ee.emit('e2', { msg: 'e2 ok' });
ee.emit('e2', { msg: 'e2 not ok' });

// remove

//заготовили фцию
const f3 = data => {
  console.dir(data);
};
//повесили эту загтовленную фцию f3 на name e3 и потом сразу её оттуда ремувнули и попытались ее заэмитить но у нас уже не получится потому что мы ее удалили
ee.on('e3', f3);
ee.remove('e3', f3);
ee.emit('e3', { msg: 'e3 not ok' });

// count

//выводим на экран сколько событий подписано на e4
ee.on('e4', () => {});
ee.on('e4', () => {});
console.log('e4 count', ee.count('e4'));

// clear

//почистили e4, но e1 останется
ee.clear('e4');
ee.emit('e4', { msg: 'e4 not ok' });
ee.emit('e1', { msg: 'e1 ok' });

//clear без аргументов уже всё почистило
ee.clear();
ee.emit('e1', { msg: 'e1 not ok' });

// listeners and names

//навешиваем целую шару обработчиков
ee.on('e5', () => {});
ee.on('e5', () => {});
ee.on('e6', () => {});
ee.on('e7', () => {});

//получаем все обработчики на e5
console.log('listeners', ee.listeners('e5'));
//все именна событий
console.log('names', ee.names());
