'use strict';

// Модель акторов для паралельных вычеслений
// что бы показать пример использования акторов - мы будем мониторить АПИ и если он падает, то мы будем высылать почтовое сообщение, а если подымается, то высылаем смс что сервер поднялся
// Идея акторов заключается в том что это асболютно независимые программные компоненты, которые не делают вызовы друг к другу вообще, у них нет общих данных, они только обмениваются сообщениями. Это такие независимые компоненты, которые могут находится внутри одного процесса, внутри тредов, могут находится внтури разных процессов. Разные процессы могут быть запущены внутри одной машины, а так же на нескольких и модель акторов позволяет нам легко масштабировать приложения если они уже написаны в таком стиле что всё постеронно на обмене сообщениями, то размазать её на десятки машин не составляет никакого труда, главное что у этих акторов нет никакого общего состояние и их личное состояние(те переменные и структуры данных) которое они внутри себя в памяти заводят - не должны быть критичны, то-есть если какой-то актор падает, то мы должны его перестартануть и ничего не должно сломаться - этот принцип еще называется share nothing - они ничего между собой не шарят, у них нет разшаренных ресурсов между собой, они не конкорирует между собой не за доступ к оперативной памяти, не к каким-то объектам которые находятся в оперативной памяти.
// У нас была лекция по Мьютексам - это тоже другая модель для работы с параллельными вычислениями, там мы блокировали доступ к одним объектам, если определенный процесс(какая-то задача) начинала с ними работать, мы должны были заблокировать доступ к этим объектам, потом когда эта задача закончит какуе-то отомарную опперацию(опперация которая несёт в себе законченный отамарный смысл) с объектом, тогда она снимает lock и другие процессы или треды могут занимать этим объектом или этой частью памяти
// Лучше всего делать задачу на процессы так что бы каждый из них выполнял какуе-то отдельную задачу(парсинг, конвертация, рендеринг и тд), каждого из акторов мы можем запустить несколько штук и они будут на вход принимать запросы
// Что бы не случалась перегрузка этих акторов(что бы мы их не заплевали задачами), то на вход к акторам нужно поставить очередь и если актор занят, то задача ставится в очередь и потом как только освобождается, то из этой очереди задачу вычитывает и так акторы падают то лучше всего эти очереди держать не в самих акторах, а в каком-то менеджере который будет управлять очередями, разсылать эти задачи, и он еще будет управлять обменами сообщениями между акторами, один актор может обратить по именни к другому и прислать к нему какие-то данные, при этом эти данные передаются не по ссылке, они должны серилизоваться, те отправится в другое приложение(там серилизоваться) и положиться в память еще раз, то-есть все данные при взаимодействие между данными - они копируются, в этом весь смысл ведь тогда они друг другу не мешают

// В этом 1 примере у нас модель акторов реализована в одном процессе и при помощи асинхронного программирования(здесь мы используем асинхронные функции и промисы) и принципы кооперативной многозадачности, когда всё происходит в одном треде и как только одна функция закончила свою работу -> она может дать другой функции управления
// У нас в примере написан самый просто актор на 50 строчек для того что бы они могли обмениваться сообщениями друг с другом

const actors = new Map();

class ActorSystem {
  static register(actor) {
    const ready = [];
    const instances = [];
    const queue = [];
    actors.set(actor.name, { actor, ready, instances, queue });
  }

  static start(name, count = 1) {
    require(`./actors/${name.toLowerCase()}.js`);
    const record = actors.get(name);
    if (record) {
      const ActorClass = record.actor;
      const { ready, instances } = record;
      for (let i = 0; i < count; i++) {
        const instance = new ActorClass();
        ready.push(instance);
        instances.push(instance);
      }
    }
  }

  static async stop(name) {
    const record = actors.get(name);
    if (record) {
      const { instances } = record;
      await Promise.all(instances.map((instance) => instance.exit()));
    }
  }

  static async send(name, data) {
    const record = actors.get(name);
    if (record) {
      const { ready, queue } = record;
      const actor = ready.shift();
      if (!actor) {
        queue.push(data);
        return;
      }
      await actor.message(data);
      ready.push(actor);
      if (queue.length > 0) {
        const next = queue.shift();
        this.send(name, next);
      }
    }
  }
}

module.exports = ActorSystem;
