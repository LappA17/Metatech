'use strict';

// Это контракт Монады, с chain, с map, только не хватает метода apply
// Монада - это абстракция которая представляет собой последовательное вычисление, или программная абстракиця которое это последовательное вычисление может задавать своим синтаксисом

// Обрати внимания что у объекта future нет никакого состояния(нет контекста в котором хранилось бы состояние, в предыдущем примере это были mapper и value) ! Здесь же на вход приходит не значение, а executor - это как раз то что мы взяли из паттерна открытый конструктор - это функция которя принимает на вход коллбек, в который она возвращает значение, благодаря Паттерну открытого конструктора наш Фьючер остался чистым, значение в него так и не попало, когда мы создаём экземпляр Фьючера, то в него value никак не попадает потому что никто не вызвал никакого метода, а там только внутри вызова этих методов есть вот тут вот executor(successed); начинает работать executor какой-то. И это значение попадает к нам из фции которая задается внутри executor и отправляет уже в коллбек successed.
// Но тем не менее можно сказать что каждый future будет хранить в себе какое-то состояние, но оно - скрытое состоняние - executor. Наш фьючер хранит только ссылку на executor

// Дальше у нас есть map что бы построить цепочку. В map приходит fn и этот fn делает какое-то приобразование над тем значение которое из констуктора пришло. В executor должно вернуться какое-то значение и дальше фция map должна создать цепочку вычислений. Дальше мы из фции map вызываем метод chain() который должен создать еще один экземпляр этого же Фьючера и положить в него то что будет вычисленно из этого вызова открытого конструктора (value) => fn(value).fork(resolve) те chain срзау начнёт вызывать открытый конструктор, и тут у нас внутри вызывается статический метод of, который создаёт новый экземпляр Фьючера, но кладёт в него новое значение future.of(fn(value)).
// В данном this.chain((value) => future.of(fn(value))); случае chain вынимает из Монады future предыдущее значение(value), потом пропускает его через фцию fn(), потом нам fn что-то вернули и это значение опять отправилось в статический метод of -> и теперь мы посмотрим что там в of происходит

// посмотрим chain() - Здесь у нас внутри вызывается fork, при чем два раза, один раз внутри, вынимается значение this.fork(value => ) вот это value вынимается. Потом это значение пропускается через фцию fn, а фция fn попадает в метод chain() вот отсюда (value) => future.of(fn(value)), дальше из этого fn вернулся новый Фьючер и у этого Фьючера вызывается fork и туда передаёт resolve, а этот resolve взят уже из нового Фьючера, то-есть return future(resolve => ) нам на входе в методе chain даётся новый resolve, внутри происходит fork и в этот fork уже передается resolve - fork(resolve). Они таким образом сцепляются в цепочку исполнения, которая никогда не начнется пока кто-то не вызовит первый раз Форк снаружи
// У нас каждый следующий future передаёт в executor самого же себя и там внутри лежит какое-то значение которого пока что нет еще у future потому что она скрыто от него через открытый конструктор const future1 = future((r) => r(5)) вот здесь самый первый future получает на вход фцию и внутри себя эту фцию хранит -> дальше мы у первого future вызвали map и там создался второй future и первый фьючер имеет ссылку на фцию, а второй фьючер имеет ссылку на map и дальше по цепочке. И только после того как мы делаем fork() у нас вызывается форк сначала у предыдущего Фьючера, не у первого, то-есть в нашем примере он форк сначала вызвится у самого последнего map -> потом форк вызовится еще у предыдущего и еще и тд. То-есть форки вызываются в обратном порядке. И фьючер у которого вызывается форк только в этом моменте может из предыдущего Фьючера получить какое-то значение, но результат опять отложен через коллбек(к примеру x => x ** 3) и предыдущий фьючер опять подписывается на получения значения при помощи открытого констурктора у предыдущего фьючера и вот так оно доходит до самого верхнего где нам скалярное значение в коллбек попадает future((r) => r(5)), а дальше вычесления идут в прямом порядке, как только у нас вылизла 5ка в значение фьючера (r) => r(5) - эта 5ка попала в его рантайм контекст, потом она прошла через фцию переданную в первый map -> потом он передал(зарезолвил) во второй map и так дальше по цепочки они друг друга резолвят. То-есть сначала фьючеры идут назад, получают исходное значение и затем опять вперед. При помощи такого синтаксиса мы можем описать последовательность вычислений !

const future = (executor) => ({
  chain(fn) {
    return future((resolve) => this.fork((value) => fn(value).fork(resolve)));
  },

  map(fn) {
    return this.chain((value) => future.of(fn(value)));
  },

  fork(successed) {
    executor(successed);
    return this;
  },
});

// метод of - это статический метод, который мы примешиваем к фции future, который вызывает его же собственный future передавая value в качестве открытого конструктора (resolve) => resolve(value)
// внутри of у нас value опять попадает в паттерн открытый конструктор(у нас этот паттерн используется практически в каждом методе) и там он опять зависает, потому что это значение value - оно и future.of не начнет работать до того как кто-то не вызовит fork и не запустит этот экзекьютор

future.of = (value) => future((resolve) => resolve(value));

// Usage

// Здесь мы кладём значение в future при помощи открытого конструктора ((r) => r(5)), мы эту 5ку не просто кладём в конструктор Фьючера, а возвращаем её через коллбек r(resolve)
// потом мы с помощью цепочки map отображаем и изменяем значение и каждый раз делая при этом новый Фьючер
// в конце метод fork() стартует цепочку вычислений
// пока мы задавали его при помощи открытого конструктора и через map модифицировали то НИКТО НИЧЕГО Не Резолвил, те фцию r куда пришла 5ка в конструктор никто не вызывал и фции map тоже никто не вызывал, а они просто все сохранялись, у нас просто каждый раз создавался после нового map новый фьючер куда в констурктор приходил старый фьючер. У нас в примере 4 фьючера(первый и три мепа). При чем мы могли споконо метод fork сейчас не вызывать, а вызвать его в любой нужный для нас момент

const future1 = future((r) => r(5))
  .map((x) => {
    console.log('future1 started');
    return x;
  })
  .map((x) => ++x)
  .map((x) => x ** 3)
  .fork((x) => {
    console.log('future1 result', x);
  });

console.dir({ future1 });

// Промисы отличаются от Фьючеров тем что как только происходит Promise.resolve(6) то эта 6ка сразу же попадает в Объект Промиса и Промис сразу резолвд и он сразу идёт в одном направление, то-есть исполнение Промиса только идёт в одном направление, а создание future идет сначала вперед -> исполнение идет сначала в обратном порядке, а потом вперёд
// Благодаря этому future является ленивым, без состояния(потому что 5ка в него сразу не попадает, а ждёт внутри фции)

const promise1 = Promise.resolve(6)
  .then((x) => {
    console.log('promise1 started');
    return x;
  })
  .then((x) => ++x)
  .then((x) => x ** 3)
  .then((x) => {
    console.log('promise1 result', x);
  });

console.dir({ promise1 });

/*
future1 started
future1 result 216
{
  future1: {
    chain: [Function: chain],
    map: [Function: map],
    fork: [Function: fork]
  }
}
{ promise1: Promise { <pending> } }
promise1 started
promise1 result 343
*/
