'use strict';

// Коллектор - это более проста абстракиця по сравнению с Адаптером. Если мы будем использовать ее в прикладном коде, то наш Коллектор будет знать что ему нужно собрать какие-то кусочки данных(если у нас к примере в коде вызывается Три асинхронные фции, к примеру два Промиса, один Коллбек, то наш Коллектор соберёт эти три кусочка данных), дальше Коллектор будет ожидать когда эти три кусочка данных к ней прийдут(это могут быть три ключа или массив их трёх элемнетов к примеру) и вот когда все эти ключи прийдут то Коллектор просто вызовит события и мы узнаем что всё пришло. В каком порядке они прийдут это уже не особо важно, главное что мы можем иметь такой объект Коллектор где-то в utils и передавать его в разные части нашей программы и разные части могут отдавать туда разные кусочки данных которые мы ожидаем. Это фактически как Просим(Если Промис символизируте собой НЕвозвращаенные даныне то Коллектор - это как Объект который символизирует собой НЕсобранные ответы, когда кто-то ему напехал эти несобранные ответы, то он в конце отработал и отдал их пользователю). То-есть мы можем в разные части программы распехать ссылкки на один и тот же объект и в него будут сходится данные из разных частей программы

//Коллект может собирать ключи по колиеству, а может по именни. В этом примере по кству. Если в метод collect передаётся число - то по кству, если массив строк то по именнам

//Как только случится timeout - то это будет значит что мы не успели собрать все эти три части данных и сразу отработает doneCallback и в него прийдет ошибка и мы поймём что под определённое выделенное время мы не смогли собрать нужных данных, то-есть к примеру сходить в апи, сходить в бд , файловая система, еще что-то - и вот они за это время в timeout не прошли и doneCallback выдаст ошибку. Если бы мы писали на коллбеках или на Промисах то нам бы пришлось это в ручную реализовывать.
//Такой подход через Коллектор может быть и актуален и на Фронте - если мы нажали на кнопочку и должно произойти несколько запросов

/*
  Мы можем передать массив ключей которые мы хотим собирать
  dc
    .collet(['key1', 'key2', 'key3'])
    .timeout(5000)
    .done((err, res) => {
      если ошибка, то-есть ключи не успели собраться за 5 секунд то выдать ошибку
      если ключе все собранные то обрабатываем res и отдаём данные
    })

  А ниже мы при помощи pick добавляем эти три ключа которые прийдут в массив в collect
  ds.pick('key1', 1)
  ds.pick('key2', 2)
  ds.pick('key3', 3)

  Если мы схитрим и сделаем что-то такое, то мы получим ошибку потому что нам прийдет только два ключа не смотря на то что вызова три, а наш Коллеткор будет ожидать ровно три ключа
  dc1.collect('key1', 1);
  dc1.collect('key1', 2);
  dc1.collect('key2', 2);
*/

const DataCollector = function (expected, timeout, callback) {
  this.expected = expected;
  this.count = 0;
  this.data = {};
  this.finished = false;
  this.doneCallback = callback;
  this.timer = setTimeout(() => {
    if (this.finished) return;
    const err = new Error('Collector timed out');
    this.finished = true;
    this.doneCallback(err);
  }, timeout);
};

DataCollector.prototype.collect = function (key, data) {
  if (this.finished) return;
  this.count++;
  if (data instanceof Error) {
    this.finished = true;
    this.doneCallback(data);
    return;
  }
  this.data[key] = data;
  if (this.expected === this.count) {
    if (this.timer) clearTimeout(this.timer);
    this.finished = true;
    this.doneCallback(null, this.data);
  }
};

// Usage

const dc1 = new DataCollector(3, 1000, (err, result) => {
  console.log('dc1');
  console.dir({ err, result });
});

dc1.collect('key1', 1);
dc1.collect('key2', 2);
dc1.collect('key3', 3);

const dc2 = new DataCollector(3, 1000, (err, result) => {
  console.log('dc2');
  console.dir({ err, result });
});

dc2.collect('key1', 1);
dc2.collect('key2', 2);

const dc3 = new DataCollector(3, 1000, (err, result) => {
  console.log('dc3');
  console.dir({ err, result });
});

dc3.collect('key1', new Error('Collect an error'));
dc3.collect('key2', 2);
dc3.collect('key3', 3);
