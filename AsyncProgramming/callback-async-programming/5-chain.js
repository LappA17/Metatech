'use strict';

// Use list and chaining syntax to build sequence

//Здесь так же всегда будет последовательно, так же долго(не паралельно) будет исполнятся код, но за то красивая цепочка вызовов благодаря фции chain(). В этом примере мы избавились от того что у нас последовательность вызовов размазана на весь файл и от елочки коллбеков
//Мы это сделали при помощи синтаксиса Чейнинга и при помощи замыкания.

//мы хоть здесь и не передаём в сам chain() какой-то аргумент но можем, но мы по дефолту ставим его в null потому что chain у нас это рекурсиваня фцункция, она будет сама себя вызывать что бы установить цепочку вызовов
//мы внутри этого chain будем строить ДВУХСВЯЗАННЫЙ список и все эти фции которые мы сюда передаем типа readConfig будем сюда складывать и потом их исполнять
const chain = (prev = null) => {
  console.log('Create element');
  const cur = () => {
    console.log('Reverse from ' + (cur.fn ? cur.fn.name : 'null')); //здесь мы выводим имя фции что бы посмотреть в каком порядке мы проиттераируемся
    if (cur.prev) {
      //если у этой фции есть ссылка на prev
      //то мы строим обратную ссылку с односвязного списка - двухсвязанный, мы связываем односвязный список обратными ссылками
      cur.prev.next = cur;
      cur.prev(); //и опять вызываем метод prev
    } else {
      //как только мы долши что у нас нет метода prev - то мы вызываем метод forward и начнется иттерация в прямом порядке
      cur.forward();
    }
  };
  //здесь мы создаём двухсвязанный список, мы к этой фции cur которую создали выше, добавляем то что у нас было в аргументе prev
  cur.prev = prev;
  //у элемента двухсвязанного списка будет два свойства fn и args. fn - это фция которую нужно будет при помощи метода do навесить на этот элемент, а args - это те аргументы которые туда навесятся. И fn и args это указатели и fn будет фционального типа а args - массив
  cur.fn = null;
  cur.args = null;
  cur.do = (fn, ...args) => {
    //и мы внизу сохраняем их в те свойства которые мы выше до этого заготовили
    cur.fn = fn;
    cur.args = args;
    //после того как мы внутри фции do сохранили свойства и аргументы во внутрь cur - мы рекурсивно вызвали chain(cur) с ссылкой на cur у который этот метод do и вызволся, таким образом наш chain вызовется с самого начала и еще раз создаст элемент двухсвязанного списка и у него ссылка на  cur уже будет записана в cur.prev потом будут созданы новые fn и args пустые и опять метод do и тд
    return chain(cur);
  };
  //сама фция cur начинает иттерироваться в обратно порядке
  cur.forward = () => {
    console.log('Forward');
    //cur - это у нас указатель на текущий элемент в двухсвязном списке
    if (cur.fn)
      //мы проверим или у текущего элемента фция не пустая
      //то мы вызовим эту фцию с нужными нам аргументами
      cur.fn(...cur.args, (err, data) => {
        console.log('Callback from ' + cur.fn.name);
        console.dir({ data });
        //если ошибки не было и у текущего элемента есть ссылка на следующий элемент то мы вызываем forward() у след элемента
        if (!err && cur.next) cur.next.forward();
        //а если была ошибка или мы дошли до конца то мы скажем на какой фции мы закончили
        //важно помнить что у каждой фции есть свойство name !!!
        else console.log('End at ' + cur.fn.name);
      });
  };
  return cur;
};

// Emulate asynchronous calls

const wrapAsync =
  fn =>
  (...args) =>
    setTimeout(() => fn(...args), Math.floor(Math.random() * 1000));

// Asynchronous functions

const readConfig = wrapAsync((name, callback) => {
  console.log('(1) config loaded');
  callback(null, { name });
});

const selectFromDb = wrapAsync((query, callback) => {
  console.log('(2) SQL query executed');
  callback(null, [{ name: 'Kiev' }, { name: 'Roma' }]);
});

const getHttpPage = wrapAsync((url, callback) => {
  console.log('(3) Page retrieved');
  callback(null, '<html>Some archaic web here</html>');
});

const readFile = wrapAsync((path, callback) => {
  console.log('(4) Readme file loaded');
  callback(null, 'file content');
});

// Usage

//Фция chain пораждает замыкание во внутрь которой складыаются все ссылки на эти фции(readConfig и тд) и вторым параметром те аргументы с которыми мы должны эти фции вызывать(то-есть 'myConfig' и тд). И мы здесь нигде не передаём коллбеки, потому что сама фция chain внутри замыкания умеет составить структуру данных таким образом что бы в одну фцию передать коллбек, потом получить коллбек назад и когда коллбек вернётся - передать управления следующей фции, у нас этот chain сам умеет связывать(цеплять) все эти фции
//у нас вызывается фция chain() у которого создаться пустой элемент в котором есть фция и аргументы, дальше вызывается do и readConfig записывается в fn, а myConfig' в массив аргументов(то-есь мы можем запихнуть туда куча любых других аргументов)
//для JS такой способ вызова фций не новый, если мы возьмём setTimeout(fn, 1000, 'config', { name: 'Ruslan' }, 'html') вот все эти аргументы после передачи времени таймера отправятся в фцию fn
//таким образом мы построили цепочку, chain() вернул пустой элемент, дальше вызываем do и у нас этот пусой элемент вызвал метод do а тот рекурсивно опять вызвал chain и передал предыдущий экземпляр chain ему в аргументы и они всцепились в список и уже do c selectFromDb уже вызовится у совершенно другого chain, этот do уже пойдет по той же самой цепочки
//важно понимать что у нас будет не 4 элемента, а 5 ! потому что в конце создаться новый пустой элемент который ждёт что кто-то на него навесится на do, хотя правильно будет это оптимизировать что бы было 4
const startChain = chain()
  .do(readConfig, 'myConfig')
  .do(selectFromDb, 'select * from cities')
  .do(getHttpPage, 'http://kpi.ua')
  .do(readFile, 'README.md');

//этот startChain уже вылез из последнего экземпляра чейна в списке do(в нашем случае readFile) и он так пойдет вызываться, то-есть задом на перед, и нас это совершенно не устраивает, мы бы хотели что бы он вызывался сверху вниз и это делает фци cur.forward()
startChain();

console.log('END');
/*Если мы захотим исполнить startChain(); к примеру не один раз а два разаЖ
startChain();
startChain();
То они уже в свою очередь будут исполнятся паралельно друг-другу хотя сами readConfig и тд нет ! */
