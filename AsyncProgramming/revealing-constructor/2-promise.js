'use strict';

// resolve) => resolve(5) - это как раз Констурктор Промиса который в коллбек возвращает константу
// это как раз таки и называется открытый конструктор
// В Промисах открытый конктруктор необходим изменять состояние Промиса из pending в resolve или rejected состояние
// но вообще этот паттерн можно использовать для кучу других вещей

{
  const promise = new Promise((resolve) => resolve(5));
  console.dir({ firstPromise: 'true', promise }); // firstPromise: 'true' я дописал что бы было понятно какой промис резолвится
}

// Если в первом примере Промис сразу резолвится
// то здесь мы внутри конструктора(в той функции которую мы передали в контруктор) в ней внутри мы ожидаем секунду и потом резолвим
// Этот слушатель promise.then((x) => console.log({ x })); навешивается до того как зарезолвиться Промис, те до вызова сетТаймаута и резолва в него
// а второй then(слушатель) навешивается после того как Промис зарезолвится

{
  const promise = new Promise((resolve) => {
    setTimeout(() => {
      resolve(5);
    }, 1000);
  });
  console.dir({ promise });
  promise.then((x) => console.log({ x }));
  setTimeout(() => {
    promise.then((y) => console.log({ y }));
  }, 1500);
}

/*
{ firstPromise: 'true', promise: Promise { 5 } }

{ promise: Promise { <pending> } }
{ x: 5 }
{ y: 5 }

  Мы видим что если мы подписываемся на получение значения из Промиса - это можно сделать до того как он зарезолвился или после
  Благодаря тому что мы используем паттерн открытого конструктора - это и можно сделать ! 
  Если мы в Промис передавали константу или фцию которая возврщает констнта как в первом примере, то мы бы не могли вернуть из этой функции какое-то значение, если бы в Том промисе где resolve на сетТаймаут 1 сек был бы return то он бы сразу и вернул и мы бы не могли подождать секунду. 
  Благодаря тому что мы хотим из функции передаваемый в аргумент Промиса возврвщать значения через секунду то нам нужно фция как коллбек
*/
