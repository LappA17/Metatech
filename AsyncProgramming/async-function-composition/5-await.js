'use strict';

// точно так же как в примере с рекурсией к нам сюда приходят большое кство функций, число которых нам зарание не известно, только здесь уже не коллбеки, а асинхронный контракт

// Как работает фция compose ? Опять все функции помещаем в массив, дальше возвращаем асинхронную лямбду async (x), её вызывает пользователь с нашим аргументом(в нашем случае 7)

const compose =
  (...fns) =>
  async (x) => {
    let res = x; // res изначально будет равен нашему аргументу, в нашем случае 7
    for (const fn of fns) {
      // на каждой итерации мы будем получать следующую фцию из массива и будем вызывать её с новым результатом res
      // таким образом res на каждой итерации будет разный и следующая фция которая его будет вызывать будет вызывать его с новым предыдущим результатом, все банально просто !
      // а await мы делаем потому что фция возвращает нам Промис и мы должно его дождать и расспаковать значение в переменную res
      res = await fn(res);
    }
    return res;
  };

// Usage

// это наши фции с асинхронным контрактом, их результат будет упакован в Промис

const inc = async (x) => x + 1;
const twice = async (x) => x * 2;
const square = async (x) => x * x;

const f = compose(inc, twice, square, inc);

// так как фция f имеет асинхронный контракт и мы должны вызывать её через await - по-этому мы должны обернуть её асинхронный ИФИ

(async () => {
  const res = await f(7);
  console.dir({ res });
})();

// { res: 257 }
