'use strict';

// Наш compose написан без async/await , потому что всё сделанно через обычные Промисы, по-этому и фция не асинхронная

const compose =
  (...fns) =>
  (x) => {
    const fn = fns.shift();
    if (fns.length === 0) return fn(x);
    // если рекурсия не дошла до конца и не попала в if выше, то мы вызовим fn с аргументом x(7ка в нашем случае)
    // и предпологаем что из этого fn вернётся Промис
    // дальше через then мы достаем значение из этого Промиса, если это вызов первой фции до inc, twice и тд то там будет 7ка,
    // потом здесь compose(...fns) мы композируем остальные фции которые мы не успели исплнить из массива
    // и уже в скомпозированную фцию передаем этот res который будет после каждой функции менять своё значене аж до 257 как в нашем примере
    // ну и самом собой на кажом вызове этих фций в массиве fns будет меньше и меньше
    return fn(x).then((res) => compose(...fns)(res));
  };

// Usage

// Здесь без async/await , но каждая из этих фций свой результат сама упаковывает в Promise.resolve
// те все упаковывается в Промис, контракт у этих фций точно такой же, только синтаксис другой
// отличие в том что Promise.resolve сразу создаёт зарезолвленный Промис, а функция откладывает свои действия на микротаск, по-этому этот пример будет чуть быстрее

const inc = (x) => Promise.resolve(x + 1);
const twice = (x) => Promise.resolve(x * 2);
const square = (x) => Promise.resolve(x * x);

const f = compose(inc, twice, square, inc);

f(7).then(console.log);

// 257
