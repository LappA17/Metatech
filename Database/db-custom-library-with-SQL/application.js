'use strict';

//мы обернули Постгресовские драфера в свою библиотечку db
const db = require('./db.js');

const pg = db.open({
  host: '127.0.0.1',
  port: 5432,
  database: 'application',
  user: 'marcus',
  password: 'marcus',
});

console.dir({ pg });

//этот select возвращает Cursor
//у нас здесь используется синтаксис Chaning когда один метод(фция) возвращает ссылка на this то-есть все этим методы после экземпляра select, то-есть where, fields, order, then все они будут возвращать ссылка на this того самого Cursor. Потому что у каждого из этих методов в конце написанно return this
//все эти методы не запускают pool query, а они только подготавливают запроса и накапливают его в Cursor,
//мы можем этот Курсор присвоить в переменную, а она может с ним уже что-то там делать, потом исполнить и результат уже будет хранится в этом курсоре
pg.select('pg_tables')
  //мы в where можем дописывать доп ограничения. Мы в db.js написали многие ухрещение с синтаксическим сахаром что бы мы могли не писать равно или больше меньше, то-есть мы перед значением можем написать какой-то знак schemaname: '>public' и тогда этот символ(=< >= = и тд)  отрежется от выражения и превратится в sql опператор а сама строчка public уже будем самим значением(в массив аргументов запроса пойдёт только паблик)
  //то-есть в where мы просто пишем запрос в виде объекта
  .where({ tableowner: 'marcus', schemaname: 'public' })
  //дальше передаём arr с полями, почему удобней передавать именно так а не строчку разделенную пробелами - потому что мы очень часто такие queryBuilderы будем строить не просто так взяли и в коде написали список полей, а список полей откуда-то берёт, те у нас есть пользовательский интерфейс, пользователь из 20 колоночек видит 5 и он присылает какие именно колоночки он хочет увидеть именно массивом
  //мы сюда можем предумать себе еще какие-то новые методы, .order допустим, или метод для отсартировки, потом это все приобразится в sql и исполнится а мы сможем потом вывести этот sql на эран что бы посмотреть что там нагенерилось
  .fields(['schemaname', 'tablename', 'tableowner', 'hasindexes'])
  .order('tablename') //мы отсоритурем таблицу по именам
  .then(rows => {
    console.table(rows);
    pg.close();
  });
