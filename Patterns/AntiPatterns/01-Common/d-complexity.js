'use strict';

// Antipattern: Accidental complexity
// Усложнять
// вместо просто сделать фцию хеллоу ворлд - мы делаем класс со статическим методом, асинхронный и тд
class Application {
  static async main() {
    console.log('Hello world');
  }
}

Application.main();

// Best practice of middleware boilerplate
// здесь мы добавляем обработчик на роутинг на goods и user
// Во-первых у нас огрмное повторение кода
// Во-вторых у нас в этом обработчике происходит парсинг параметров http запросов(const id = parseInt(req.params.id);), формирование запроса в виде строки(const query = 'SELECT * FROM users WHERE id = $1';), исполнение запроса(pool.query...), обработка ошибки и ее выброс плюс отдача хттп статуса 200, потом сериализация(json(data.rows);), то-есть очень много всего что в каждом запросе нужно производить и тут мы в каждом из этих обработчиков мы будем это дублировать, мало того что мы смешиваем разные уровни абстракции, мы так же бизнес логику смешали с хттп протоколом и работой с Базой данных. То-есть тут как минимум должно было быть три слоя и если казалось бы если мы разделим на разные три слоя то сложность кода будет больше(именно архитектурная и структурная сложность кода будет больше), но тем не менее бизнес логика будет очень маленькая
router.get('/user/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const query = 'SELECT * FROM users WHERE id = $1';
  pool.query(query, [id], (err, data) => {
    if (err) throw err;
    res.status(200).json(data.rows);
  });
});
router.get('/goods/:id', (req, res) => {
  const id = parseInt(req.params.id);
  const query = 'SELECT * FROM goods WHERE id = $1';
  pool.query(query, [id], (err, data) => {
    if (err) throw err;
    res.status(200).json(data.rows);
  });
});

// AWS boilerplate
// как Амазон предлогает нам делать облачные фции
// очень похоже на мидлвеер
// Получается что один url имеет такой обработчик как у нас ниже. Теперь представим что нам нужно написать обработчик для другого url. Мы его копипастим, меняем там кусочек sql оператора и может чуть по другому парсаю аргумнеты http запроса и у меня везде повторяется подключение к БД, везде повторяется исполнения запроса и сериализация везде повторяется. И все это можно свести к более простому примеру как в // The essence
exports.handler = (event, context, callback) => {
  const { Client } = require('pg'); // прям из обработчика делать require()
  const client = new Client();
  client.connect(); // прям из обработчика коннектимся к БД
  const id = parseInt(event.pathParameters.id); // парсим http заголовки
  const query = 'SELECT * FROM users WHERE id = $1';
  // исполняем запрос
  client.query(query, [id], (err, data) => {
    // отдаем сериализациованный результат
    callback(err, {
      statusCode: 200,
      body: JSON.stringify(data.rows), // Это сериализация
    });
  });
};

// The essence
// тот же самый пример кода, где у нас асинхронаая фция получаем один аргумент, этот аргумент мы берём из параметров запроса, нужно расспарсить запрос, запрос нужно парсить либо куском бизнес логики либо фреймворком и прочитав тело этой фции он может понять что аргумент называетс id и его можно выпарсить из запроса и кроме того нам не нужно постоянно соединятся с БД, у нас есть application внутри database и внутри database уже должен быть какой-то коннекшен пул, не нужно создавать коннекшен к базе или тимболее пулл конекшенов
// Если нам нужно будет получить какой-то условный массив из БД, на 300 стрчоек, потом запарсить его в JSON или допустим порезать на кусочки и передать через стрим - это уже полностью дела Фреймворка !! А бизнес-логику лучше писать как ниже !!
// То-есть в этом куске кода мы не работаем не с http протоколом, не со структурами данных, не строим сами SQL запросы, не сериализуем. Мы одни данные получили, как-то обработали их при помощи бизнес-логики и всё, а всё остальное уже ложится на плечи Фреймворка !!!
// То-есть всю эту сложность мы должны выносить в отдельные места и абстрагировать её и тогда сложность придметной области будет отделена от сложности алгоритом или от сложно сериализации и тд
async (id) => await application.database.select('users').where({ id });

// Бизнес-логика - это последовательность действий, которая дектуется предметной областью. Предметная область - это задача которую мы решаем(к примеру учет товаров, поставки, управление роботом и тд)
// Фреймворки - решают системную задачу, фреймворки ничего не знают про поставки, роботом и учет товаров, Фреймворк который рендерит знает к примеру про кнопочки, другой фреймворк или библиотека знает как формулировать запрос к БД, третий как данные приобразовыввать в памяти
// Мидлвеер - это контракт, который говорит что у нас есть какой-то контекст и роутер, которые находит нужны обработчики и их вызывает и эти мидлвары мы можем добавлять между запросами и дачи ответов, вот по-этому они так называются. Мы можем до мидлваров и после дать ответ и они строятся по цепочки вызовов. Мидлвары можно хорошо использовать, но как правило его используют ужасно, даже Амазон предлагает плохой пример !!!
// Рекурсию нужно использовать ситуативно, бывают такие задачи где без рекурсии нужно написать 30 строк кода, а с рекурсией вместиится в 3-4, по-этому по возможности циклами, но рекурсию по ситуации тоже можно, но рекурсия не оптимизируется JSтом
