// Здесь пример как в Метархии описываются контракты внешних методов

// у нас ниже описан метод в виде Объекта
// в ключ method мы присваиваем асинхронную функцию и у неё два аргумента а и b которые она сравнивает, то-есть мы в реализации этого метода ВЫБРОСИЛИ все проверки
// а теперь мы хотим входящие и выходящие данные описать декларативно и мы просто в ключ parameters описываем их типы

// Так как у нас в рантайме всё это дело должно работать, и runner всего этого дела(этих контрактов), он должен прочитать эти два ключа parameters и returns
// и этот раннер должен считать эти поля и по-сути он проверит и выбросит исключение если что
// и потом нам с фронта(там где ниже // client) просто вот так вот его вызвать api.example.compare({ a: 1, b: 2 }); как буд-то это просто метож, но на самом деле этот метод обёрнут в проверки и там автоматически случатся все проверки, результат упакуется в Промис и пришлется нам вообще на другую машину, это у нас межпроцесовое взаимодействие, и у нас получается что такой контракт не может быть проверин не Тайпскриптовыми классами, интерфейсами, типами и всем остальным и ТайпСкриптовые тайпинги тут не прокатят потому что это все работает в рантайме!!! И нам нужно добавить к методу метаданные на вход и на выход, то-есть одна сторона взаимодействие(наш клиент) он уверен что сервер предоставляет ему этот контракт и контракт может быть проверен сначала на клиенте и повторно можно проверить на сервере "а вдруг кто-то не пользовался нашим стандартным клиентом и контракт никто не проверял" и сервер должен повторно перепроверить этот контракт ну и перепроверить результаты что бы клиент точно получил то что он ожидает(он получит boolean или если свилтся в исключение то попадет в ключ errors где мы можем передавать ошибки) и уже эти ошибки на клиенте будут обернены в try catch то мы уже эти ошибки словим на клиенте
// Но если у нас две стороны доверянные и нам нужно с экономить на проверках и увеличить производительность то мы можем погонять это по системе наши котракты, а потом их отключить !

// server

({
  parameters: {
    a: 'number',
    b: 'Account', // можем к примеру b: { value: 'number' } те нам приходит b в видео объекта с полем value которое number ну и так далее, таких много проверок
  },

  method: async ({ a, b }) => {
    const result = a > b;
    return result;
  },

  returns: 'boolean',

  errors: {},
});

// client

try {
  const res = await api.example.compare({ a: 1, b: 2 });
} catch (err) {}
