'use strict';

// функция curry поможет нам избежать вызова partial каждый раз. В этом примере она специально страшно написанно
// реализация этой фции в данном примере работает не самым лучшим образом и он практически не читается

// в фцию curry передается фция (fn) и на выход тоже возвращается фция(только уже каррирования - в которую можно преедавать аргументы в любом порядке и она подсчитает только когда мы уже все передадим !), таким образом нам нужно взять из фции fn кство её аргументов - мы это можем сделать при помощи fn.length ! ,естественно это будет работать только для тех фций у которых кство аргументов явно заданно(как наш sum4(a, b, c, d)) и если длина фции fn больше чем кство переданных аргумнетов fn.length > args.length то мы рекурсивно вызываем каррирование, а если кство аргументво переданных в лямбду такое же или больше как длина фции fn то просто вызываем эту фцию без коррирование и передаём туда аргументы fn(...args);
// как случается опять коррирование: опять передаётся лямбда (fn, ...args1) в фцию curry(). У этой лямбды опять есть первый аргумент фция и nое кство остальных аргумнетов и из неё возвращается опять лямбда (...args2) => которая захватывает втуруя группу аргументов, вторая группа склеивается с первой fn(...args1.concat(args2)) и передаются в ту фцию которую нужно коррироваться - fn . Откуда (fn, ...args1) в эту лямбду отправляются ? - вот из этого вызова (fn, ...args) - это наш ИФИ, сразу вызванна фция

const curry =
  (fn) =>
  (...args) =>
    fn.length > args.length
      ? curry(
          (
            (fn, ...args1) =>
            (...args2) =>
              fn(...args1.concat(args2))
          )(
            // ...args1, ...args2 лучше прописать
            fn,
            ...args
          )
        )
      : fn(...args);

// Usage

const sum4 = (a, b, c, d) => a + b + c + d;

// у нас здесь опять есть фция с 4ма аргумнетами и мы эту фцию саму вызываем в const y1
// так же мы делаем себе фцию f которая будет каррированным sum4(фция из 4 аргументов каррированная)
// и теперь мы фцию f можем по разному вызывать: или передать сначало три аргумента потом еще один f(1, 2, 3)(4); или сразу передать все аргументы f(1, 2, 3, 4); и тд
// f(1, 2, 3)(4); важно понимать что каждый раз эти открытые и закрытые скобочки ()() вызывают фцию, те сначала вызовится фция с аргумнеами 1, 2, 3, она возвращает другую фцию и в эту другую фцию мы уже передаём 4 и когда мы дошли до кства аргументов 4, то оно уже вычесляет конкретное значение

const f = curry(sum4);
const y1 = sum4(1, 2, 3, 4);
const y2 = f(1, 2, 3, 4);
const y3 = f(1, 2, 3)(4);
// y4, y5, y7 не работают ! В этом и проблема той фции curry которую мы написали выше, потому что в плохо написанном коде тяжело дебажить ошибку !
//const y4 = f(1, 2)(3)(4); // передаём сначала два аргумента, а потом по одному
//const y5 = f(1)(2)(3)(4); // 4 раза по цепочки вызываем, те после каждого вызова будет возвращаться фция
const y6 = f(1)(2, 3, 4);
//const y7 = f(1)(2)(3, 4);
const y8 = f(1, 2)(3, 4);
console.log(y1, y2, y3, y6, y8);
