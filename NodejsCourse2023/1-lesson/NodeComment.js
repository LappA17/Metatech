/*
Представим себе картинку где нам приходит по http, websocker и другим протоколам запросы 
Они попадают в нашу Ноду
Нода - это рантайм js, для бекенда. Что бы мы могли запускать js на серверной стороне
Для этого нам нужно: v8 - виртуальная машина для js, но вообще можно вставить другие движки типа от Сафари, или Манки, но в8 самый оптимальный
Библиотека libuv - дает нам eventloop, не блокирующий ввод вывод, собственно асинхроную работу с внешним АПИ. 
libuv внутри себя имеет третпул - по-дефолту это 4 треда, то-есть Нода никогда не была однопоточной
Таким образом мы понимаем что по-дефолту libuv использует 4 треда + один а то и больше тредом берет на себя v8 
Куча разных написаных на с и с++ и других языках адонах могут локировать свои треды если им это нужно потому что они могут обращаться к операционной системе, по-этому бинарные библиотеки могут локировать свои сишные треды
N-API - кроме сишных адонов, у нас есть н-апи - это еще один интерфейс который позволяет писать адоны на разных языках на расте, на чем угодном внешнем и вставлять их в наше приложение на Ноде
openssl - есть куча уже написанных на с,с++ библиотек которые мы уже используем в нашей Ноде - та же криптография, для архивации, для шифрования, для доступа к DNS или хттппарсер - это всё библиотеки которые написаны на разных языках которые предоставляют нам стандарты библиотеки Ноды. Но ко всем ним нужно обеспечить как-то доступ. 
Часть нодовского апи которое уже идет под капотом написанна на js а часть на с++, кроме того внутри v8 запускается часть Ноды которая написана на js, там же запускается те модули которые мы написали на веб-асембли, там же все зависимости которые мы скачали из npm, и небольшая часть само наше приложение

fs.readFile(...cb)
У нас как контракт принято передавать коллбек в ноде как последний аргумент, и в этот коллбек ошибка будет передавать error first а все данные следующие аргументы
Мы из кода можем вызвать любую фцию типа ReadFile которая имеет в себе коллбек или условно сетТаймаут - то-есть что угодно и этот коллбек попадает в стандартную библиотеку, то-есть в то апи которое мы вызвали, fs.readFile находяется в стандартной библиотеке, коллбек туда попадает и дальше наша бибилотека может использовать третпул из libuv что бы выполнять доступ к файлам, к сети и любые другие внешние операции, если посчитает нужным то третпул использовать не будет. И когда стандартная библиотека Ноды посчитает что асинзронная операция которую мы вызвали и результат нужно вернуть в этот callback(в callback queue который находится в libuv) то она помещает этот коллбек в callback queue, и там этих коллбеков в callback queu может накопится некоторое большое количество коллбеков. И теперь нам нужно сделать так что бы эти фции вызвались внутри v8 - то-есть внутри нашего приложения, потому что это фции и им нужно вернуть результат. Так вот наш евентлуп пока он постоянно крутится(то-есть пока мы не выходим из приложения либо пока мы не заблокировали этот евентлуп какими-то долгими сихроными операциями)  он у нас евент луп постоянно вычитывает коллбеки из этой очереди каких-то готовых результатов -> потом заберает коллбек и выбрасывает его на стек, то-есть делает вызов внутри v8(js) и представим что он передает первым аргументво ошибку и уже наша клиентская програма ее обрабатывает и уже как-то ее логирует и тд, потом приходит второй коллбек в качестве первого аргумента вместо ошибки он передает null и наш callback queue таким образом опусташается и евент лупу оттуда уже нечего вычитывать и таким образом наш процесс Ноды завершается 

У Ноды - долгая жизнь приложения, то-есть у нас есть идея АСИНХРОННОГО ВВОДА-ВЫВОДАЫ такая что один тред можем использоваться для обслуживания в нем нескольких запросов приходящих по сети,а обычно это сотни или тысячи приходящих паралельных подсоединений пользователей которые постоянно присылают поток запросов, по-этому это большой выиграш в экономии памяти, в ресурсах операционной системы, тредов и такой вещи как переключение контекстов в CPU, когда мы маштабируемся процесами или тредами у нас происходит очень много переключений контекстов в CPU, а это сохранение всего состояния процессора и потом его востановления, когда мы между процессами переключаемся - это очень дорогая операция если тредов или процессов наплодить большое количество, то вообще всё будет уходить на переключение контекстов и система замерзнет. А в Ноде мы можем сделать примерное количество тредов или процессов столько сколько у нас ядер на процессоре, а может чуть меньше но это нужно всегда измерять в проекте, сколько тредом будет жить на конкретном железе на котором мы запускаем или конкретной вирутальной машины с этой бизнес логикой что мы запускаем
Благодаря чему все эти процессы могут паралельно обрабатываться ? Потому что у нас асинхронный ввод/вывод и он не блокируется, он часто содержит операции ожидания(к примеру мы хотим прочитать какой-то пакет из сети, что-то из файла, дали задание операционной системе и ждём пока она нам не вернет какой-то буфер с данными) и пока она ожидает мы можем еще что-то делать к примеру выполнять еще какой-то кусок js, давать еще какое-то параельное задание и тд

В основе Ноды лежит следующая идея что теперь наши процесы,в отличие от апачевской модели, могут жить в памяти достаточно долго, у них долгое время состояние в памяти сохраняется, мы там можем что-то закешировать и его не нужно постоянно поднимать там с диска или с базы , у нас может долго сохранятся соединения с базой данных(если мы запустили наше приложение - то мы можем сделать пулл конекшен с тем же постгресом, редисом или другой субд), сразу у нас там этих конекшинов может быть несколько 10тков и каждый запрос когда приходит - берёт конекшн из этого пула и вернул в пул, таким образом этот пул конекшинов - переиспользуется и если там конекшинов нет, то этот запрос должен подождать пока какой-то другой запрос не вернёт в пул конекшинов то что он оттуда взял - таким образом у нас переиспользуется соединения с базой данных
Но в этом уплотнение есть и побочные эффекты - у нас всё от разных пользователей, от разных конекшинов попало в одна адресное пространство в памяти - у нас один инстенс Ноды сразу обслуживает многих пользователей, по-этому если он упадет то всем будет плохо, если кто-то его взломает то сразу получит доступ ко всему, и нужно много внимания уделять безопастности

У нас сервер внутри приложения, а не наоборот

Мы можем делать меньше межпроцессорового взаимодействия, если плюс ко всему что мы имеем к ноде и сократив использования памяти, сократим ввод-вывод, сократим взаимодействие с внешними другими процессами(с дисками, базыми данными), вообще отсутствие ввода-вывода еще быстрее работает чем асинхронный(неблокирующий) ввод-вывод, по-этому мы можем использовать упреждающие чтение, кеширование, отложенную запись

Как лучше импортировать ?
//
import * as fs from 'node:fs' либо const fs = require('node:fs') если коммон js
import * as http from 'node:http'
import * as path from 'node:path'
//Что бы мы не перепутали именна этих библиотек с npm библиотеками

const PORT = 8000

const STATIC_PATH = path.join(process.cwd(), './static')

const toBool = [() => true, () => false]
//
process.cwd() - это текущая папка и джоинем ее с именнем static - так что бы в текущей папке мы предпологали что у нас есть папка со статическими файлами и оттуда мы будем сёрвить какие-то файлики которые мы хотим что бы отдавать в браузер
const toBool = [() => true, () => false] - а здесь мы по нулевому индексу всегда константнтно возвращаем true, а по другому false

//
Самая большая Проблема Ноды !
Мы получили систему где все пользователи которые подключились к одному треду и которые обслуживаются в одном инстенсе Ноды - они попали все в одно адресное пространство и это очень небезопасно и очень ненадежно. По-этому нужно реализовать изоляцию контекса между этими пользователями. По-этому в грамотных руках на ноде можно писать корпоротивные приложение если делать ее безопастной и надежной. 
У нас для изоляции есть process(очень тяжелая изоляция), есть Треды(полегче), есть v8::Isolate(она еще легче) и v8::context(самая легкая). Но самая легкая - замыканиями, но замыкания не всегда можно использовать а в ограниченных случаев и нужно модифицировать весь свой писания кода

//
То что можно и нужно использовать: undici(уже де-факто часть Ноды), pino, fastify, ws, llparse(уже де-факто часть Ноды)
Тимур категорически против использования axios, express и тд зависимостей, потому что огромный риск скачать вирус

//
Антипатерны:
mixin, middleware, refference pollution, prototype pollution
*/
